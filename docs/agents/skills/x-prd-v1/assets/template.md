# Product Requirements Document (PRD)

**Purpose**: This PRD defines _what_ needs to be built and _why_, from a business and user perspective. It intentionally avoids technical implementation details. Developers will later derive a **Technical Functional Specification (TFS)** from this PRD.

---

- **PRD Status** (Draft / Reviewed / Approved): …
- **Last Updated** (YYYY‑MM‑DD): …
- **Owner**: …

---

<!--
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
-->

&nbsp;

## Overview

### Feature Name

> Clear, human‑readable name of the functionality.

{name}

### Problem Statement

- What user or business problem does this feature solve?
  - …
- Why is this problem important _now_?
  - …
- What happens if we don't solve it?
  - …

### Goals & Success Metrics

**Primary Goals**

- …
- …

**Success Metrics (KPIs)**

- Quantitative: (e.g., conversion rate, error reduction, load time)
  - …
- Qualitative: (e.g., user satisfaction, usability feedback)
  - …

### Non‑Goals / Out of Scope

> Explicitly list what is _not_ included to avoid scope creep.

<!--
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
-->

&nbsp;

## Users

- **Persona 1** (description, needs, pain points) — …
- **Persona 2** (if applicable) — …

<!--
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
-->

&nbsp;

## Permissions & Security

- Who can access this feature? …
- Role‑based or condition‑based visibility? …

<!--
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
-->

&nbsp;

## Data Requirements

> What information must exist? Define inputs, outputs, and facts the feature needs. Think nouns. They mostly help in building all types of libs. e.g., "Currency code", or "Location Profile answers".

- …
- …

<!--
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
-->

&nbsp;

## Functional Requirements

> What must the feature do (goals)? Define observable behaviour. Think verbs. They mostly help in building 'ui' libs. e.g., "Feature must show user's energy consumption". Functional requirement IDs (e.g., NAME-FR-01) can be used in Unit tests later to create a stable, shared reference for a piece of business logic across product. Typically map to **unit tests `describe()` blocks**.

Each requirement should be atomic, testable, and ordered based on priority.

1. {NAME-FR-01} — {description}
2. {NAME-FR-02} — {description}

<!--
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
-->

&nbsp;

## User Experience & Flows

### User Journey

Describe the happy path step‑by‑step:

1. User enters …
2. User performs …
3. System responds …

### Alternative / Edge Flows

- Empty states
  - If …; then …
- Error scenarios
  - If …; then …
- Permission‑restricted scenarios
  - …
- First‑time vs returning user
  - First‑time? …; returning user? …

### UI Responsibilities

- What the UI MUST display
  - …
- What the UI must _not_ do (e.g., no data fetching, no business decisions)
  - …

### Accessibility & Localization

- Accessibility requirements (WCAG, keyboard navigation)
  - …
- Localization / i18n expectations
  - …

> Diagrams or Figma links can be referenced here.

<!--
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
-->

&nbsp;

## Business Rule Breakdown

> Each subsection represents a **testable business rule**. Rule IDs (e.g., NAME-BR-01) can be used in Unit tests later to create a stable, shared reference for a piece of business logic across product. Each item should map to **unit tests `it`**. Frontend developers will later map these rules to unit tests across `ui` libraries.

Each business rule must be written in a way that it can be validated via Given / When / Then scenarios, testable, and ordered based on priority.

### 1. {NAME-BR-01}

**Description** (Test intent / scenario name)
Explain the rule in plain business language.

**Inputs** (Arrange)

- What information does this rule rely on? (user input, backend data, configuration)

**Expected Behaviour** (Act + Assert)

- What should happen when the rule is applied?

**Edge Cases / Exceptions** (Negative & boundary)

- What happens when data is missing, invalid, or partial?

### 2. {NAME-BR-02}

_(Repeat the same structure for each rule)_

<!--
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
-->

&nbsp;

## Analytics & Tracking

> These help in defining Analytics logs (e.g., Firebase Analytics).

- Events to be tracked
  - When …; log …
- Success / failure signals
  - … succeeds; log …
  - … fails; log …
- Funnel or journey tracking
  - View → Interact → Submit → Success
  - View → Interact → Submit → Failure
  - …

<!--
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
-->

&nbsp;

## Dependencies & Risks

### Dependencies

- Backend docs
- UI/UX
- External services

### Risks & Mitigations

- **Risk:** User didn't fill out Location Profile  
  **Impact:** High  
  **Mitigation:** Show a clear message in the empty state.

<!--
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
-->

&nbsp;

## Acceptance Criteria (High‑Level)

> Unlike 'Business Rules' which are Atomic and can be mapped to single lib unit tests (low-level rules), 'Acceptance Criteria' are Observable outcomes of the feature as a whole and can be mapped to E2E tests (high-level verification points). They are written from a product perspective.

- Given … when … then …
- Given … when … then …

<!--
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
-->

&nbsp;

## Open Questions

- …
- …

<!--
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
-->

&nbsp;

## Appendices

- Figma links
- API references (high‑level)
- Related PRDs
