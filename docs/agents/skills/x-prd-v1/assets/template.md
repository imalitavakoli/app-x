# Product Requirements Document (PRD)

**Purpose**: This PRD defines _what_ needs to be built and _why_, from a business and user perspective. It intentionally avoids technical implementation details. Developers will later derive a **Technical Functional Specification (TFS)** from this PRD.

---

- **PRD Status** (Draft / Reviewed / Approved): â€¦
- **Last Updated** (YYYYâ€‘MMâ€‘DD): â€¦
- **Owner**: â€¦

---

<!--
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
-->

&nbsp;

## â„¹ï¸Overview

### Feature Name

> Clear, humanâ€‘readable name of the functionality.

{name}

### Problem Statement

- What user or business problem does this feature solve?
  - â€¦
- Why is this problem important _now_?
  - â€¦
- What happens if we don't solve it?
  - â€¦

### Goals & Success Metrics

**Primary Goals**

- â€¦
- â€¦

**Success Metrics (KPIs)**

- Quantitative: (e.g., conversion rate, error reduction, load time)
  - â€¦
- Qualitative: (e.g., user satisfaction, usability feedback)
  - â€¦

### Nonâ€‘Goals / Out of Scope

> Explicitly list what is _not_ included to avoid scope creep.

<!--
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
-->

&nbsp;

## ğŸ‘¤Users

- **Persona 1** (description, needs, pain points) â€” â€¦
- **Persona 2** (if applicable) â€” â€¦

<!--
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
-->

&nbsp;

## ğŸ”Permissions & Security

- Who can access this feature? â€¦
- Roleâ€‘based or conditionâ€‘based visibility? â€¦

<!--
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
-->

&nbsp;

## ğŸ“‹Data Requirements

> What information must exist? Define inputs, outputs, and facts the feature needs. Think nouns. They mostly help in building all types of libs. e.g., "Currency code", or "Location Profile answers".

- â€¦
- â€¦

<!--
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
-->

&nbsp;

## ğŸ› ï¸Functional Requirements

> What must the feature do (goals)? Define observable behaviour. Think verbs. They mostly help in building 'ui' libs. e.g., "Feature must show user's energy consumption". Functional requirement IDs can be used in Unit tests later to create a stable, shared reference for a piece of business logic across product. Typically map to **unit tests `describe()` blocks**.
>
> Tip! If functionality name is `ng-posts` or `posts`, a functional requirement ID can be `POSTS-FR-01`.

Each requirement should be atomic, testable, and ordered based on priority.

1. {NAME-FR-01} â€” {description}
2. {NAME-FR-02} â€” {description}

<!--
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
-->

&nbsp;

## ğŸ§³User Experience & Flows

### User Journey

Describe the happy path stepâ€‘byâ€‘step:

1. User enters â€¦
2. User performs â€¦
3. System responds â€¦

### Alternative / Edge Flows

- Empty states
  - If â€¦; then â€¦
- Error scenarios
  - If â€¦; then â€¦
- Permissionâ€‘restricted scenarios
  - â€¦
- Firstâ€‘time vs returning user
  - Firstâ€‘time? â€¦; returning user? â€¦

### UI Responsibilities

- What the UI MUST display
  - â€¦
- What the UI must _not_ do (e.g., no data fetching, no business decisions)
  - â€¦

### Accessibility & Localization

- Accessibility requirements (WCAG, keyboard navigation)
  - â€¦
- Localization / i18n expectations
  - â€¦

> Diagrams or Figma links can be referenced here.

<!--
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
-->

&nbsp;

## ğŸ’¼Business Rule Breakdown

> Each subsection represents a **testable business rule**. Rule IDs (e.g., NAME-BR-01) can be used in Unit tests later to create a stable, shared reference for a piece of business logic across product. Each item should map to **unit tests `it`**. Frontend developers will later map these rules to unit tests across `ui` libraries.

Each business rule must be written in a way that it can be validated via Given / When / Then scenarios, testable, and ordered based on priority.

### 1. {NAME-BR-01}

**Description** (Test intent / scenario name)
Explain the rule in plain business language.

**Inputs** (Arrange)

- What information does this rule rely on? (user input, backend data, configuration)

**Expected Behaviour** (Act + Assert)

- What should happen when the rule is applied?

**Edge Cases / Exceptions** (Negative & boundary)

- What happens when data is missing, invalid, or partial?

### 2. {NAME-BR-02}

_(Repeat the same structure for each rule)_

<!--
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
-->

&nbsp;

## ğŸ“ŠAnalytics & Tracking

> These help in defining Analytics logs (e.g., Firebase Analytics).

- Events to be tracked
  - When â€¦; log â€¦
- Success / failure signals
  - â€¦ succeeds; log â€¦
  - â€¦ fails; log â€¦
- Funnel or journey tracking
  - View â†’ Interact â†’ Submit â†’ Success
  - View â†’ Interact â†’ Submit â†’ Failure
  - â€¦

<!--
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
-->

&nbsp;

## ğŸš©Dependencies & Risks

### Dependencies

- Backend docs
- UI/UX
- External services

### Risks & Mitigations

- **Risk:** User didn't fill out Location Profile  
  **Impact:** High  
  **Mitigation:** Show a clear message in the empty state.

<!--
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
-->

&nbsp;

## âœ”ï¸Acceptance Criteria (Highâ€‘Level)

> Unlike 'Business Rules' which are Atomic and can be mapped to single lib unit tests (low-level rules), 'Acceptance Criteria' are Observable outcomes of the feature as a whole and can be mapped to E2E tests (high-level verification points). They are written from a product perspective.

- Given â€¦ when â€¦ then â€¦
- Given â€¦ when â€¦ then â€¦

<!--
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
-->

&nbsp;

## â“Open Questions

- â€¦
- â€¦

<!--
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
-->

&nbsp;

## ğŸ”—Appendices

- Figma links
- API references (highâ€‘level)
- Related PRDs
